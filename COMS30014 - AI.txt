#separator:tab
#html:true
What are the tree key parts of a Prolog/Datalog Program?&nbsp;	Facts: <br>movie(american_beauty, 1999).<br><br>Rules: <br>released_after(M,Y) :- movie(M,Z), Z &gt; Y.<br><br>Queries:<br>?- actor(_, A, _), director(_, A)
How can this be procedurally interpreted?&nbsp;<br><br>vintage(A) :- (actor(M,A,_) ; actress (M,A,_)), movie(M,Y), Y&lt;1970.	<div>To find a vintage movie star, it suffices to find an actor or actress A who played a role R1 or R2 in some movie M, find the year Y of its release, and check it was before 1970.</div>
What is wrong with this query?&nbsp;<br><br><div>vintage(A) :- Y&lt;1970 , (actor(M,A,_) ; actress (M,A,_)) , movie(M,Y).</div>	Variable Y is unbound when called, as querys execute left to right, this causes an error.&nbsp;
What are the classical logic versions of these Prolog operators:<br>&nbsp;:-&nbsp; &nbsp; &nbsp;,&nbsp; &nbsp; &nbsp;;&nbsp; &nbsp; &nbsp;\+&nbsp;	If, And, Or, Not
Transitive Closure is ...	One element is reachable from another by chaining applications of a base relation. (The property that allows you to make recursive calls that end in a base case).
How Blind Search Algorithms work at a high level?&nbsp;	"<div>They look for goals in a systematic way, but do not take the</div>
<div>quality of partial solutions into account (e.g. using heuristics)</div>"
What is the Prolog implementation of Depth-First Search?	"<div><b>search_df([Goal|Rest],Goal):-</b></div>
<div><b>&nbsp; goal(Goal).</b></div>
<div><b>search_df([Current|Rest],Goal):-</b></div>
<div><b>&nbsp; children(Current,Children),</b></div>
<div><b>&nbsp; append(Children,Rest,NewAgenda),</b></div>
<div><b>&nbsp; search_df(NewAgenda,Goal).</b></div>"
What is the Prolog implementation Breadth-First Search?&nbsp;	"<div><b>Search_bf([Goal|Rest],Goal):-</b></div>
<div><b>&nbsp; goal(Goal).</b></div>
<div><b>search_bf([Current|Rest],Goal):-</b></div>
<div><b>&nbsp; children(Current,Children),</b></div>
<div><b>&nbsp; append(Rest,Children,NewAgenda),</b></div>
<div><b>&nbsp; search_bf(NewAgenda,Goal).</b></div>"
What are the Depth-First Attributes?	agenda = stack (LIFO)<br>incomplete: may get trapped in an infinte branch<br>no shortest-path property (returns first found)<br>requires O(BxN) memory
What are the Breadth-First Attributes?	agenda = queue (first-in first-out)<br>complete: will find all solutions<br>firt solution found along shortest path<br>requires O(B^n) memory&nbsp;
Iterative Deepening	Depth-First Search but limit depth at each stage<br>Combines optimality of BFS and Memory Benefits of DFS
How does Best-First Search interate?&nbsp;	When adding children into the adgenda you can order them via a heuristic metric. You append them to the back but pre-process them via some heuristic.<br><br>Agenda = priority queue<br>Behaviour depends on heurstic employed (optimality / speed etc.)
What does A Search aim to minimise?	Aims to minimise the total cost of solution paths via some node n using a metric (aka f score) which combines cost of reaching current node with cost of moving to next node.&nbsp;<br><br>f(n) (cost along path through n)<br>g(n) (cost to reach current node n-1)<br>h(n) (cost to go from n-1 to n)<br><br>f(n) = g(n) + h(n)<br><br>if g(n) == 0 (for all n) then you have Greedy Best first<br>if h(n) == 0 (for all n) then you have BFS&nbsp;
What is Global Optimism?&nbsp;	A heuristic is globally optimistic if the estimated cost of reaching a goal is always less than the actual cost (from any node n). i.e Eucledian Distance in GridWorld
Simple Hill Climbing	"<div>Repeatedly switch to the first better solution found in the local</div>
<div>neighbourhood of the current solution</div><div><br></div><div>Deterministic&nbsp;</div><div><br></div><div>Pick first found better node</div>"
Steepest Hill Climb&nbsp;	"<div>Repeatedly switch to the best solution found in the local</div>
<div>neighbourhood of the current solution</div><div><br></div><div>Non-Stochastic</div>"
<div>Simple Tabu Search</div>	"<div>Hillclimb, but don’t consider solutions on a (finite) list of</div>
<div>previously visited solutions</div>"
<div>Simulated Annealing</div>	"<div>Hillclimb, but tolerate moves to worse solutions with a probability</div>
<div>that is initially high, but decreases as more steps are made</div>"
Explore/Exploit Tradeoff for BFS/DFS	<div>Breadth-first search explores, while depth-first exploits.</div>
What is the difference between strong and weak AI?	Strong AI -&nbsp;addressing abstract general-purpose problem solving<br>Weak AI -&nbsp;addressing concrete domain-specific task performance
What is the difference between knowledge-driven AI and data-driven AI?	Knowledge-driven AI - symbolic, declarative, white-box<br>Data-driven AI - connectionist, distributed black-box
Is&nbsp;movie(american_beauty,1999). a fact, rule, or query?	It is a fact.<br>Facts are in the form&nbsp;predicate(terms,…).
Is&nbsp;released_after(M,Y) :- movie(M,Z), Z&gt;Y. a fact, rule, or query?	It is a rule.<br>Rules use operators like:<br><ul><li>“:-” if&nbsp;</li><li>“ ,” and</li><li>“;” or</li><li>“\+” not</li></ul>
Is&nbsp;?- actor(_, A, _), director(_, A). a fact, rule, or query?	It is a query.
What is the swipl command for loading source code from multiple files?	?- [file1, file2].
What is the swipl command to&nbsp;detect and reload any modified definitions?	make.
How do you exit prolog?	halt.
What are the comparison operators for ground numbers?	&lt;, &gt;, =&lt;, &gt;=, ==, \==
What are the comparison operators for arbitrary terms?	@&lt;, @&gt;, @=&lt;, @&gt;=, ==, \==
What is an atom?	<ol><li>A string of characters starting with a lowercase</li><li>A string of characters between single-quotes</li><li>A string of special characters</li></ol>
What is a variable?	<ol><li>A string that starts with an uppercase letter</li><li>A string that starts with an underscore</li></ol>
What are complex terms?	A functor followed by a sequence of arguments.
What is arity?	The number of arguments a functor takes.
What are clauses?	Any statement that ends in a full-stop.
